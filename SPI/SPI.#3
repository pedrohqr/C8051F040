/*
Pedro Henrique de Queiroz Ramos
Gustavo Felipe Goncalves Reis
*/
#include "..\util.h"
#include <stdio.h>

#define CS P2_3

void esc_RAM_SPI(unsigned int end, unsigned char dado)
{
	unsigned char end_L, end_H;
	end_L = end;
	end_H = end >> 8;

	CS = 0;

	// Operação de escrita
	SPI0DAT = 0x02;

	// Enquanto não sinalizou que o dado atual do buffer de transmissão foi para o shift register
	while(!TXBMT);

	SPI0DAT = end_H;
	while(!TXBMT);
	SPI0DAT = end_L;
	while(!TXBMT);
	SPI0DAT = dado;
	while(!TXBMT);
	SPIF = 0;
	// Enquanto não terminou a transmissão do shift register
	while(!SPIF);
	SPIF = 0;
	CS = 1;
}

unsigned char le_RAM_SPI(unsigned int end)
{
	unsigned char end_L, end_H;
	end_L = end;
	end_H = end >> 8;

	CS = 0;

	// Operação de leitura
	SPI0DAT = 0x03;

	// Enquanto não sinalizou que o dado atual do buffer de transmissão foi para o shift register
	while(!TXBMT);

	SPI0DAT = end_H;
	while(!TXBMT);
	SPI0DAT = end_L;
	while(!TXBMT);
	SPI0DAT = 0x00;
	while(!TXBMT);
	SPIF = 0;
	// Enquanto não terminou a transmissão do shift register
	while(!SPIF);
	SPIF = 0;
	CS = 1;
	return (SPI0DAT);
}
/*
#define CS_Serial_Flash_bit P2_3
#define _SERIAL_FLASH_CMD_RDID  0x9F  // 25P80
#define _SERIAL_FLASH_CMD_READ  0x03
#define _SERIAL_FLASH_CMD_WRITE 0x02
#define _SERIAL_FLASH_CMD_WREN  0x06
#define _SERIAL_FLASH_CMD_RDSR  0x05
#define _SERIAL_FLASH_CMD_ERASE 0xC7  // 25P80
#define _SERIAL_FLASH_CMD_EWSR  0x06  // 25P80
#define _SERIAL_FLASH_CMD_WRSR  0x01
#define _SERIAL_FLASH_CMD_SER   0xD8  //25P80

//
//	Lê o status do Write Enable Latch(WEL).
//
unsigned char SerialFlash_Read_WEL(void)
{
	// Read WEL status
	CS_Serial_Flash_bit = 0;
	SPI0DAT = _SERIAL_FLASH_CMD_RDSR;
	while(!TXBMT);
	SPI0DAT = 0x00; // Dummy byte
	while(!TXBMT);
	SPIF = 0;
	while(!SPIF);
	SPIF = 0;
	CS_Serial_Flash_bit = 1;

	return (SPI0DAT & 0x02) >> 1;
}

//
//	Lê o status do Write In Progress(WIP).
//
unsigned char SerialFlash_Read_WIP(void)
{
	// Read WIP status
	CS_Serial_Flash_bit = 0;
	SPI0DAT = _SERIAL_FLASH_CMD_RDSR;
	while(!TXBMT);
	SPI0DAT = 0x00; // Dummy byte
	while(!TXBMT);
	SPIF = 0;
	while(!SPIF);
	SPIF = 0;
	CS_Serial_Flash_bit = 1;

	return SPI0DAT & 0x01;
}

//	
//  Envia um byte para ativar a escrita na M25P80.
//
void SerialFlash_WriteEnable()
{
  	// Write enable command
    CS_Serial_Flash_bit = 0;
	SPI0DAT = _SERIAL_FLASH_CMD_WREN;
  	while(!TXBMT);
	SPIF = 0;
	while(!SPIF);
	SPIF = 0;
  	CS_Serial_Flash_bit = 1;

	while(!SerialFlash_Read_WEL());
}

//
//	Escreve um byte na memória flash M25P80.
//
void esc_RAM_SPI(unsigned char _data, unsigned long address)
{
	SerialFlash_WriteEnable();
    
    CS_Serial_Flash_bit = 0;
	SPI0DAT = _SERIAL_FLASH_CMD_WRITE;
	while(!TXBMT);
	SPI0DAT = 0x00;
	while(!TXBMT);
	SPI0DAT = address >> 8;
	while(!TXBMT);
	SPI0DAT = address;
	while(!TXBMT);
	SPI0DAT = _data;
	while(!TXBMT);
	SPIF = 0;
	while(!SPIF);
	SPIF = 0;
    CS_Serial_Flash_bit = 1;

    // Wait for write end
    while(SerialFlash_Read_WIP());
}

//
//	Lê um byte da memória flash M25P80.
//
unsigned char le_RAM_SPI(unsigned long address)
{
  	CS_Serial_Flash_bit = 0;

  	SPI0DAT = _SERIAL_FLASH_CMD_READ;
	while(!TXBMT);
	SPI0DAT = 0x00;
	while(!TXBMT);
	SPI0DAT = address >> 8;
	while(!TXBMT);
	SPI0DAT = address;
	while(!TXBMT);
	SPI0DAT = 0x00;		// Dummy byte
	while(!TXBMT);
	SPIF = 0;
	while(!SPIF);
	SPIF = 0;
  	CS_Serial_Flash_bit = 1;

	return SPI0DAT;
}*/

void main(void)
{
	unsigned int i;
	unsigned char dado;
	Init_Device();
	SFRPAGE = LEGACY_PAGE;

	glcd_init();

	printf_fast_f("\01 Testing...\02 0 -> 65535");

	for(i = 0; i <= 65535; i++)
	{
		printf_fast_f("\02 %u -> 65535", i);

		dado = 170; // 0b 1010 1010
		esc_RAM_SPI(i, dado);
		if (dado != le_RAM_SPI(i))
		{
			printf_fast_f("\03 Fail: 0x%x", i);
			break;
		}
		
		dado = 85; // 0b 0101 0101
		esc_RAM_SPI(i, dado);
		if (dado != le_RAM_SPI(i))
		{
			printf_fast_f("\03 Fail: 0x%x", i);
			break;
		}

		// Testa ultima posicao
		if (i == 65535)
			break;
	}

	if(i == 65535)
		printf_fast_f("\03 Sucess!");
	while(1);
}
